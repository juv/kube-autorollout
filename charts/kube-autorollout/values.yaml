# Default values for kube-autorollout.

# -- The number of application controller pods to run. A number higher than one does not make sense at this time as the controller is not supporting sharding.
replicaCount: 1

config:
  # -- The cron schedule to execute the main controller code, given in a format supported by Croner: https://github.com/Hexagon/croner-rust?tab=readme-ov-file#pattern. Default: "*/45 * * * * *" to execute every 45 seconds
  cronSchedule: "*/45 * * * * *"
  # -- Webserver configuration
  webserver:
    # -- Webserver port
    port: 8080
  # -- Container registries
  registries:
    - #  -- the hostname glob pattern this registry. Example: "*.your-jfrog-artifactory.example.com" or "ghcr.io" or "docker.io"
      hostnamePattern: "ghcr.io"
      # -- The Kubernetes secret to mount as an environment variable into the pod
      secret:
        # -- REQUIRED: The type of the secret - ImagePullSecret, Opaque, None. <ImagePullSecret> must define keys "name" and "mountPath". <Opaque> with Kubernetes Secret must define keys "name" and "key", optionally "username". <Opaque> with hardcoded token must define keys "token". <None> will ignore authentication to the registry.
        type: None
        # -- Kubernetes Secret name of secret type Opaque or ImagePullSecret to reference. The secret should contain the Docker Registry API token, personal access token, JFrog Artifactory identity token, etc.
        name:
        # -- REQUIRED FOR <ImagePullSecret>: The mount path of the ImagePullSecret within the kube-autorollout pod. Must be unique across registry secrets.
        mountPath:
        # -- OPTIONAL FOR <Opaque>: The key to reference of the secret. Will be referenced in the config automatically if .token is unset
        key:
        # -- OPTIONAL FOR <Opaque>: The username to use for this registry. Only required when the registry is requiring an advanced token flow for authentication, that involves trading in the username and api key / api token into a short-living OAuth2.0-esque access token. This is required for ghcr.io and docker.io
        username:
        # -- OPTIONAL FOR <Opaque>: Not recommended for production use - use .name and .key instead. A hardcoded token (api token, personal access token, etc.) to be passed in the Authorization header of the Docker manifest request to the registry
        token:
  # -- TLS configuration
  tls:
    # -- Custom CA certificates to use within kube-autorollout for verifying TLS connections to registries which present a certificate signed by a non-public CA
    customCaCertificates:
      # -- Enable or disable the custom CA certificates configuration. Only required if you connect to registries that present a TLS certificate signed by a non-public CA
      enabled: false
      secrets:
        - # -- The name of the secret to reference that includes the custom CA certificate chain
          name:
          # -- The key / subPath within the secret to mount in kube-autorollout
          subPath:
          # -- The mountPath within kube-autoroll, will be auto-wired in the config
          mountPath:

  featureFlags:
    # -- Enable JFrog Artifactory fallback when the Artifactory is configured to use the Repository Path Method (https://jfrog.com/help/r/jfrog-artifactory-documentation/the-repository-path-method-for-docker)
    enableJfrogArtifactoryFallback: false
    # -- Change the kube-autorollout patch annotation key (that triggers the redeployment) from "kube-autorollout/restartedAt" to "kubectl.kubernetes.io/restartedAt". The latter annotation is applied by kubectl when executing the command "kubectl rollout restart". Most GitOps tools like ArgoCD and FluxCD ignore the kubectl annotation from state drift detection. If you are not using this value on "true" you might need to add further configuration to ArgoCD and FluxCD to not show the kube-autorollout annotation as a state drift.
    enableKubectlAnnotation: false

#-- Sets the kube-autorollout container image. More information can be found here: https://kubernetes.io/docs/concepts/containers/images/
image:
  # -- The image repository name to use for the container image
  repository: ghcr.io/juv/kube-autorollout
  # -- Image pull policy for the container image
  pullPolicy: IfNotPresent
  # -- Image tag to use for the container image. Overrides the image tag whose default is the chart appVersion.
  tag: "v0.3.0"

# -- Kubernetes RBAC configuration
rbac:
  # -- Switch to enable/disable the creation of Kubernetes role and rolebinding for the kube-autorollout service account automatically. If false, the role and rolebinding that targets the service account must be created separately.
  enabled: true

# -- Secrets with credentials to pull images from a private registry. More information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
imagePullSecrets: []
# -- Override to the chart name
nameOverride: ""
# -- String to fully override `"kube-autorollout.fullname"`
fullnameOverride: ""

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- Automatically mount a ServiceAccount's API credentials?
  automount: true
  # -- Annotations to add to the service account
  annotations: {}
  # -- The name of the service account to use. If not set and create is true, a name is generated using the fullname template
  name: ""

# -- Pod annotations for kube-autorollout. More information can be found here: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# -- Pod labels for kube-autorollout. More information can be found here: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

# -- kube-autorollout pod-level security context. More information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
podSecurityContext: {}
  # fsGroup: 2000

# -- kube-autorollout container-level security context. More information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# --  Resource requests and limits for the kube-autorollout pod
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # requests:
  #   cpu: 100m
  #   memory: 128Mi
  # limits:
  #   cpu: 100m
  #   memory: 128Mi

# -- Liveness probe for the kube-autorollout controller. More information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe:
  httpGet:
    path: /health/live
    port: http
# -- Readiness probe for kube-autorollout controller. More information can be found here: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
readinessProbe:
  httpGet:
    path: /health/ready
    port: http

# -- Node selector for the kube-autorollout controller. More information can be found here: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
nodeSelector: {}

# -- Tolerations for the kube-autorollout controller. More information can be found here: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
tolerations: []

# -- Affinity configuration for the kube-autorollout controller. More information can be found here: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
affinity: {}
